## 사운드바 모델 매핑 Agent 발표 초안

### 1. 문제 정의 & 배경
- **문제 상황**: HDMI/BT 로그에 기록된 기기명(`NAME1~4`, `BRAND1~4`, `NAME_BT`)이 비정형·노이즈가 많아, 사운드바 모델을 정확히 인식하기 어려움.
- **목표**: 비정형 로그 텍스트로부터 **표준 사운드바 canonical 모델명**(예: `LG S90TY`)을 최대한 정확하게 식별하고, 불확실한 경우에는 **UNKNOWN**으로 안전하게 처리하는 Agent 구축.
- **활용 맥락**: 사운드바 사용 패턴 분석, 고객 경험 개선, 제품/펌웨어 전략 수립 등에 활용 가능한 기반 데이터 확보.

### 2. 제안 아이디어 및 주요 기여(Proposal of Idea & Contribution)
- **사운드바 DB 로드/정규화**
  - 사운드바 표준 모델 리스트를 Python DB(`soundbar_list.py`)에서 로드.
  - 대소문자, 공백, 특수문자, 브랜드 표기 등을 정규화하여 **검색에 최적화된 canonical 표현**으로 변환.

- **후보 문자열 생성 로직**
  - 로그 행의 `NAME[1,2,3,4]`, `BRAND[1,2,3,4]`, `NAME_BT` 필드를 활용해 **검색 질의 후보 문자열**을 생성.
  - `HDMI`, `AV` 등 의미 없는 placeholder 토큰 제거.
  - `NAN` 등 결측값 필터링.
  - **브랜드 + 모델명 조합**을 다양한 형태로 생성하여 모델명을 최대한 포착.
  - 생성된 질의 문자열에 대해 **중복 제거 및 정규화** 수행.

- **임베딩 기반 후보 검색**
  - 전체 사운드바 모델 리스트 DB를 sentence-transformers 기반 **문장 임베딩**으로 변환.
  - 질의 문자열을 임베딩 후, 코사인 유사도 기준으로 **Top-5 후보 모델**만 검색.
  - 기존 Levenshtein 문자열 거리 기반 방식 대비, 철자 변형과 문맥을 더 잘 포착하는 장점.

- **룰/패턴 기반 비사운드바 기기 탐지 (device_type, NER 미사용)**
  - 정규식/패턴 기반의 `device_type` 판별 로직으로, 사운드바가 아닌 입력 소스(스트리밍 박스, 셋톱박스, 콘솔 등)를 식별.
  - NER 모델이 아닌 휴리스틱 룰을 사용하여 **비사운드바 기기**를 사전에 걸러냄으로써, 잘못된 사운드바 매핑을 감소.

- **UNKNOWN 결정 로직**
  - Top-1 후보의 유사도 점수가 사전에 설정한 **임계치(threshold)** 미만인 경우, 해당 행은 **UNKNOWN**으로 분류.
  - 과도한 오탐(False Positive)을 줄이고, **“모를 때는 모른다고 말하는” 보수적 전략** 채택.

- **최종 사운드바 예측 파이프라인**
  - (1) 로그 전처리 → (2) 후보 질의 생성 → (3) 임베딩 기반 Top-5 후보 검색 → (4) 비사운드바 필터링 → (5) threshold 기반 UNKNOWN 결정 → (6) 최종 canonical 모델명 출력.

### 3. 평가 지표 및 실험 설정
- **평가 데이터**
  - 표본 크기 \(n = 2000\)건의 라벨링된 로그 데이터 사용.
  - 각 행에 대해 **정답 canonical 모델명 또는 UNKNOWN**을 보유.

- **평가지표**
  - **accuracy**: 최종 1개 예측의 정답 일치 비율.
  - **f1_micro / f1_macro**: 클래스 불균형을 고려한 분류 성능.
  - **top-k recall (k=1,3,5)**: 정답 모델이 Top-k 후보 안에 존재하는지 확인하는 지표.

### 4. 결과: Baseline vs 제안 로직 성능 비교

#### 4-1. Baseline (거리 유사도 기반 Levenshtein 방식)
- **설정**
  - 문자열 거리(Levenshtein 기반)로 유사도를 계산하고, 가장 가까운 모델을 선택.
  - threshold 기반 UNKNOWN 처리.
  - 표본 크기: **n = 2000**
- **성능**
  - **accuracy**: 0.5140
  - **f1_micro**: 0.6679
  - **f1_macro**: 0.5188
  - **top1_recall**: 0.6236
  - **top3_recall**: 0.6292
  - **top5_recall**: 0.6292

#### 4-2. 제안 로직 (임베딩 + 후보 생성 + UNKNOWN 로직)
- **설정**
  - 로그 정규화 + 후보 질의 생성 + 임베딩 기반 Top-5 검색 + 비사운드바 필터링 + threshold 기반 UNKNOWN 로직을 결합한 파이프라인.
  - 표본 크기: **n = 2000**
- **성능**
  - **accuracy**: 0.9721
  - **f1_micro**: 0.9859
  - **f1_macro**: 0.9497
  - **top1_recall**: 0.8845
  - **top3_recall**: 0.9721
  - **top5_recall**: 0.9801

#### 4-3. 시각화 아이디어
- **바 차트(막대 그래프)**
  - X축: 모델(Baseline vs Proposed), Y축: accuracy, f1_macro, top5_recall.
  - 세 개의 지표를 나란히 배치하여 상대적 향상 폭을 한 눈에 비교.
- **라인 차트**
  - X축: k(1, 3, 5), Y축: top-k recall.
  - Baseline과 제안 로직의 두 개 라인을 그려 **Top-k 구간별 성능 차이**를 강조.
- **포인트 메시지**
  - Baseline 대비 accuracy 및 f1_macro가 **약 2배 수준으로 향상**.
  - Top5 기준 recall이 0.6292 → 0.9801로 향상되어, **후보 목록 안에 정답을 포함시키는 능력이 크게 개선**되었음을 강조.

### 5. 시스템 제약 및 한계(Limitations)
- **대용량 데이터 처리 부담**
  - 사내 시스템에서 SQL과 Python을 결합하여 **수백만 건 규모**의 로그를 처리해야 하는 상황.
  - 임베딩 계산과 코사인 유사도 검색이 대용량 환경에서는 **성능/비용 측면에서 부담**이 될 수 있음.
  - 배치 처리, 캐싱, 인덱싱(FAISS 등 벡터 검색 엔진) 도입 필요.

- **약어 및 유사 단어 처리 한계**
  - 예: `SOUNDBAR` ↔ `SB`와 같은 약어/축약형, 철자 변형에 대해 완전한 대응이 어려움.
  - 현재는 정규화 + 임베딩으로 어느 정도 보완하지만, **도메인 특화 사전/룰 기반 보정**이 추가적으로 필요.

- **UNKNOWN 임계치 설정의 민감도**
  - threshold 값을 어떻게 설정하느냐에 따라 **정탐/오탐/미탐 트레이드오프**가 발생.
  - 업무 요구사항(보수적 vs 공격적)별로 threshold 조정 및 모니터링 필요.

### 6. 결론(Conclusion)
- **요약**
  - 비정형 로그 기반 사운드바 모델 매핑 문제에 대해, **임베딩 기반 후보 검색 + 정교한 후보 생성 + UNKNOWN 결정 로직**을 결합한 Agent를 제안.
  - 기존 Levenshtein 거리 기반 baseline 대비, **accuracy, f1_macro, top5_recall에서 큰 폭의 성능 향상**을 달성.
- **의미**
  - 실제 서비스 로그에서 사운드바 모델을 높은 신뢰도로 인식할 수 있는 기반을 마련하여, **제품/서비스 분석의 정확도와 활용도를 동시에 제고**.
  - UNKNOWN 처리를 통해 오탐을 줄여, downstream 분석 및 의사결정의 안정성을 확보.
- **향후 과제**
  - 수백만 건 규모 데이터에 대한 **스케일링 전략(벡터 인덱스, 배치 파이프라인, 캐싱)** 설계.
  - `SB`와 같은 도메인 약어, 신규 라인업에 대한 **지속적인 사전/룰 업데이트 및 모델 재학습**.
  - 사운드바 외 기기(Entity 기반 비사운드바 탐지)를 더 정교하게 분류하는 **멀티태스크/멀티라벨 확장** 검토.

